"""
Ship's Rudder Python FMU implementation.
This FMU manages the modelling of the ship's rudder.

Authors : Andreas R.G. Sitorus
Date    : Januari 2026
"""

from pythonfmu import Fmi2Causality, Fmi2Slave, Fmi2Variability, Real, Integer, Boolean, String
import math
import traceback

class Rudder(Fmi2Slave):
    
    author = "Andreas R.G. Sitorus"
    description = "Ship's Rudder Python FMU Implementation"
    
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        # Parameters (DEGREES for limits)
        self.rudder_angle_to_sway_force_coefficient = 0.0
        self.rudder_angle_to_yaw_force_coefficient  = 0.0
        self.max_rudder_angle_negative_deg          = -30.0
        self.max_rudder_angle_positive_deg          = 30.0

        # Inputs
        self.rudder_angle_deg = 0.0
        self.yaw_angle_rad    = 0.0
        self.forward_speed    = 0.0
        self.current_speed    = 0.0
        self.current_dir_rad  = 0.0

        # Outputs
        self.rudder_force_v = 0.0
        self.rudder_force_r = 0.0

        # Registration
        self.register_variable(Real("rudder_angle_to_sway_force_coefficient", causality=Fmi2Causality.parameter, variability=Fmi2Variability.fixed))
        self.register_variable(Real("rudder_angle_to_yaw_force_coefficient",  causality=Fmi2Causality.parameter, variability=Fmi2Variability.fixed))
        self.register_variable(Real("max_rudder_angle_negative_deg",          causality=Fmi2Causality.parameter, variability=Fmi2Variability.fixed))
        self.register_variable(Real("max_rudder_angle_positive_deg",          causality=Fmi2Causality.parameter, variability=Fmi2Variability.fixed))

        self.register_variable(Real("rudder_angle_deg", causality=Fmi2Causality.input))
        self.register_variable(Real("yaw_angle_rad",    causality=Fmi2Causality.input))
        self.register_variable(Real("forward_speed",    causality=Fmi2Causality.input))
        self.register_variable(Real("current_speed",    causality=Fmi2Causality.input))
        self.register_variable(Real("current_dir_rad",  causality=Fmi2Causality.input))

        self.register_variable(Real("rudder_force_v", causality=Fmi2Causality.output))
        self.register_variable(Real("rudder_force_r", causality=Fmi2Causality.output))
    
    @staticmethod
    def sat(val, low, hi):
        return max(low, min(val, hi))

    @staticmethod
    def rotation_inv_first_component(yaw_angle_rad, vel_ned):
        # u_current = (R^{-1} * vel)[0]
        # For planar rotation, R^{-1} is rotation by -yaw
        cy = math.cos(yaw_angle_rad)
        sy = math.sin(yaw_angle_rad)
        # R^{-1} = [[cy, sy],[-sy, cy]] for 2D
        u_current = cy * vel_ned[0] + sy * vel_ned[1]
        return u_current
        
        
    def get_rudder_force(self, rudder_angle_deg, yaw_angle_rad, forward_speed, vel_current_ned):
        ''' This method takes in the rudder angle and returns
            the force i sway and yaw generated by the rudder.

            args:
            delta_rad (float): The rudder angle in radians

            returs:
            v_force (float): The force in sway-direction generated by the rudder
            r_force (float): The yaw-torque generated by the rudder
        '''
        delta_rad = math.radians(rudder_angle_deg)
        u_current = self.rotation_inv_first_component(yaw_angle_rad, vel_current_ned)

        rel_u = (forward_speed - u_current)
        v_force = -self.rudder_angle_to_sway_force_coefficient * delta_rad * rel_u
        r_force = -self.rudder_angle_to_yaw_force_coefficient  * delta_rad * rel_u
        return v_force, r_force
    
    
    def do_step(self, current_time: float, step_size: float) -> bool:
        try:
            # Inputs
            yaw = self.yaw_angle_rad
            rud_deg = self.rudder_angle_deg
            u = self.forward_speed
            cs = self.current_speed
            cd = self.current_dir_rad

            # Saturate in DEGREES
            rud_deg = self.sat(rud_deg, self.max_rudder_angle_negative_deg, self.max_rudder_angle_positive_deg)

            vel_current = [cs * math.cos(cd), cs * math.sin(cd), 0.0]

            self.rudder_force_v, self.rudder_force_r = self.get_rudder_force(
                rudder_angle_deg=rud_deg,
                yaw_angle_rad=yaw,
                forward_speed=u,
                vel_current_ned=vel_current
            )
        except Exception as e:
            # IMPORTANT: do not crash host
            print(f"[Rudder] ERROR t={current_time} dt={step_size}: {type(e).__name__}: {e}")
            print(traceback.format_exc())            
            
            # Freeze dynamics safely (keep last state/outputs)
            self.rudder_force_v = 0.0
            self.rudder_force_r = 0.0
            
        return True